"""
Tools for reading, inspecting, and manipulating X-Planeâ€™s airport (apt.dat) files.
"""

from operator import attrgetter
from os import PathLike
from pathlib import Path
from typing import List, Union, Iterable, Optional, Callable

from xplane_airports.airport import Airport
from xplane_airports.aptdat_line import AptDatLine
from xplane_airports.globals import WED_LINE_ENDING
from xplane_airports.types import RowCode


class AptDat:
    """
    A container class for ``Airport`` objects.
    Parses X-Plane's gigantic apt.dat files, which may have data on hundreds of airports.
    """
    def __init__(self, path_to_file: Optional[PathLike] = None, xplane_version: int = 1100):
        """
        :param path_to_file Location of the apt.dat (or ICAO.dat) file to read from disk
        :param xplane_version The version of the apt.dat spec used by this file---overridden by any file we read (assuming it has a proper header).
        """
        self.airports = []
        """:type: list[Airport]"""
        self.xplane_version = xplane_version

        if path_to_file:
            self.path_to_file = Path(path_to_file).expanduser()
            with self.path_to_file.open(encoding="utf8") as f:
                self._parse_text(f.readlines(), path_to_file)
        else:
            self.path_to_file = None

    @staticmethod
    def from_file_text(dat_file_text: str, from_file: Optional[PathLike] = None) -> 'AptDat':
        """
        :param dat_file_text: The contents of an apt.dat (or ICAO.dat) file
        :param from_file: Path to the file from which this was read
        """
        # TODO: Provide an API to stream the file from disk so we don't have to store the whole thing in memory
        return AptDat()._parse_text(dat_file_text, from_file)

    def clone(self) -> 'AptDat':
        out = AptDat()
        out.airports = list(self.airports)
        out.path_to_file = self.path_to_file
        return out

    def _parse_text(self, dat_text: Union[List[str], str], from_file: Optional[PathLike] = None) -> 'AptDat':
        if not isinstance(dat_text, list):  # Must be a newline-containing string
            assert isinstance(dat_text, str)
            dat_text = dat_text.splitlines()

        has_file_header = dat_text[0].strip() in ('A', 'I') and 'Generated by WorldEditor' in dat_text[1]
        if has_file_header:
            self.xplane_version = AptDatLine(dat_text[1]).row_code
            assert self.xplane_version < 9999, f"Invalid X-Plane apt.dat spec version {self.xplane_version} specified in file header"
            dat_text = dat_text[2:]

        self.path_to_file = from_file
        lines = []
        for line in (AptDatLine(l) for l in dat_text):
            if line.is_airport_header():
                if lines:  # finish off the previous airport
                    self.airports.append(Airport.from_lines(lines, from_file, self.xplane_version))
                lines = [line]
            elif line.row_code != RowCode.FILE_END and line.raw:
                lines.append(line)
        if lines:  # finish off the final airport
            self.airports.append(Airport.from_lines(lines, from_file, self.xplane_version))
        return self

    def write_to_disk(self, path_to_write_to: Optional[PathLike] = None):
        """
        Writes a complete apt.dat file containing this entire collection of airports.
        :param path_to_write_to: A complete file path (ending in .dat); if None, we'll use the path we read this apt.dat in from
        """
        if not path_to_write_to:
            path_to_write_to = self.path_to_file
        assert path_to_write_to and Path(path_to_write_to).suffix == '.dat', f"Invalid apt.dat path: {path_to_write_to}"
        with Path(path_to_write_to).expanduser().open('w', encoding="utf8") as f:
            f.write("I" + WED_LINE_ENDING)
            f.write(f"{self.xplane_version} Generated by WorldEditor{WED_LINE_ENDING}{WED_LINE_ENDING}")
            for apt in self.airports:
                f.write(str(apt))
                f.write(WED_LINE_ENDING * 2)
            f.write(str(RowCode.FILE_END) + WED_LINE_ENDING)

    def sort(self, key: str = 'name'):
        """
        By default, we store the airport data in whatever order we read it from the apt.dat file.
        When you call sort, though, we'll ensure that it's in order (default to name order, just like it's always
        been in the shipping versions of X-Plane).

        :param key: The ``Airport`` key to sort on
        """
        self.airports = sorted(self.airports, key=attrgetter(key))

    def search_by_id(self, id: str) -> Optional[Airport]:
        """
        :param id: The X-Plane ID of the airport you want to query
        :returns: The airport with the specified ID, or ``None`` if no matching airport exists in this collection.
        """
        found = self.search_by_predicate(lambda apt: apt.id.upper() == id.upper())
        if found:
            assert len(found) == 1, "No two airports in a given apt.dat file should ever have the same airport code"
            return found[0]
        return None

    def search_by_name(self, name: str) -> List[Airport]:
        """
        :param name: The name of the airport you want to query
        :returns: All airports that match the specified name, case-insensitive (an empty list if no airports match)
        """
        return self.search_by_predicate(lambda apt: apt.name.upper() == name.upper())

    def search_by_predicate(self, predicate_fn: Callable[[Airport], bool]) -> List[Airport]:
        """
        :param predicate_fn: We will collect all airports for which this function returns ``True``
        """
        return list(apt for apt in self.airports if predicate_fn(apt))

    @property
    def ids(self) -> Iterable[str]:
        """
        :returns: A generator containing the X-Plane IDs of all airports in the collection. Note that these IDs may or may not correspond to the airports' ICAO identifiers.
        """
        return (apt.id for apt in self.airports)

    @property
    def names(self) -> Iterable[str]:
        """
        :returns: A generator containing the names of all airports in the collection
        """
        return (apt.name for apt in self.airports)

    def __str__(self):
        """
        :returns: The raw text of the complete apt.dat file
        """
        return WED_LINE_ENDING.join(str(apt) for apt in self.airports)

    def __getitem__(self, key: Union[int, str]) -> Airport:
        """
        Returns the airport at the specified index (if ``key`` is an int), or with the specified identifier or name (if ``key`` is a string).
         Raises a KeyError if no airport could be found using those criteria.
        """
        if isinstance(key, int):
            assert key < len(self.airports), "Tried to access index %d, but this AptDat only has %d airports" % (key, len(self.airports))
            return self.airports[key]
        assert isinstance(key, str)
        for pred in [self.search_by_id, self.search_by_name]:
            result = pred(key)
            if result:
                return result
        raise KeyError("No airport with ID or name '%s'" % key)

    def __repr__(self):
        return str(list(self.ids))

    def __eq__(self, other: 'AptDat'):
        return self.airports == other.airports

    def __iter__(self):
        return (apt for apt in self.airports)

    def __contains__(self, item: Union[str, Airport]):
        if isinstance(item, str):
            return any(apt.id == item for apt in self.airports)
        return any(apt == item for apt in self.airports)

    def __delitem__(self, key: Union[str, int]):
        if isinstance(key, str):
            self.airports = [apt for apt in self.airports if apt.id != key]
        elif isinstance(key, int):
            del self.airports[key]
        else:
            self.airports.remove(key)

    def __reversed__(self):
        return reversed(self.airports)

    def __len__(self):
        return len(self.airports)

    def __concat__(self, other: 'AptDat') -> 'AptDat':
        """
        Get a new airport data object that combines the airport data in other with the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        """
        out = AptDat()
        out.airports = list(self.airports) + list(other.airports)
        return out

    def __iconcat__(self, other: 'AptDat'):
        """
        Add the airport data in other to the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        """
        self.airports += list(other.airports)

    def __add__(self, apt: Airport):
        """
        Add the airport data in other to the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        """
        out = AptDat()
        out.airports = self.airports + [apt]
        return out

    def __iadd__(self, apt: Airport):
        """
        Add the airport data in other to the data in this object.
        Note that no de-duplication will occur---it's your job to make sure the two airport data are disjoint.
        """
        self.airports.append(apt)
        return self
